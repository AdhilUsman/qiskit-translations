


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="pl-PL" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="pl-PL" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qiskit.algorithms.optimizers &mdash; Qiskit 0.25.1 - dokumentacja</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme-override.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-variables.ade9f9d55df9d2893fc676ecd59723a1.css" type="text/css" />
    <link rel="index" title="Indeks" href="../genindex.html" />
    <link rel="search" title="Szukaj" href="../search.html" />
    <link rel="next" title="qiskit.algorithms.optimizers.OptimizerSupportLevel" href="../stubs/qiskit.algorithms.optimizers.OptimizerSupportLevel.html" />
    <link rel="prev" title="qiskit.algorithms.VQE" href="../stubs/qiskit.algorithms.VQE.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="../getting_started.html">Getting started</a>
          </li>

          <li>
            <a href="../tutorials.html">Tutorials</a>
          </li>

          <li>
            <a href="https://qiskit.org/documentation/partners/" target="_blank">Providers</a>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Applications
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/machine-learning/">
                  <span class="dropdown-title">Machine learning</span>
                  <p>QSVM, VQC (Variational Quantum Classifier), and QGAN (Quantum Generative
                    Adversarial Network) algorithms.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/nature/">
                  <span class="dropdown-title">Nature</span>
                  <p>Quantum applications in chemistry, physics, and biology.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/finance/">
                  <span class="dropdown-title">Finance</span>
                  <p>Uncertainty components for stock/securities problems, Ising translators for
                    portfolio optimizations and data providers to source real or random data.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/optimization/">
                  <span class="dropdown-title">Optimization</span>
                  <p>High-level optimization problems that are ready to
                    run on simulators and real quantum devices</p>
                </a>
              </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.slack.com">
                  <span class="dropdown-title">Slack support</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.org/textbook">
                  <span class="dropdown-title">Qiskit Textbook</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.org/events">
                  <span class="dropdown-title">Qiskit events</span>
                  <p></p>
                </a>
            </div>
          </li>
          <li>
            <a href="https://github.com/Qiskit/" target="_blank">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="rst-current-version-label">pl_PL</span>
    <span class="rst-versions-dropdown-icon"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>Języki</dt>
      
        <dd><a class="version" href="/documentation/apidoc/qiskit.algorithms.optimizers.html">English</a></dd>
      
        <dd><a class="version" href="/documentation/locale/ja_JP/apidoc/qiskit.algorithms.optimizers.html">Japanese</a></dd>
      
        <dd><a class="version" href="/documentation/locale/de_DE/apidoc/qiskit.algorithms.optimizers.html">German</a></dd>
      
        <dd><a class="version" href="/documentation/locale/ko_KR/apidoc/qiskit.algorithms.optimizers.html">Korean</a></dd>
      
        <dd><a class="version" href="/documentation/locale/pt_BR/apidoc/qiskit.algorithms.optimizers.html">Portuguese, Brazilian</a></dd>
      
        <dd><a class="version" href="/documentation/locale/fr_FR/apidoc/qiskit.algorithms.optimizers.html">French</a></dd>
      
    </dl>
    
  </div>
  <script>
    jQuery('.version').click((evt) => {
      const hash = window.location.hash
      const complete_url = evt.target.href + hash
      window.location = complete_url
      evt.preventDefault()
    })
  </script>
</div>

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Documentation homepage</a></li>
</ul>
<p><span class="caption-text">Frontmatter</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../qc_intro.html">Quantum computing in a nutshell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro_tutorial1.html">Introduction to Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing_to_qiskit.html">Twój wkład do Qiskit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration.html">Local Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
</ul>
<p><span class="caption-text">Biblioteki</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="circuit_library.html">Biblioteka obwodów</a></li>
</ul>
<p><span class="caption-text">Dokumentacja API</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="terra.html">Qiskit (Terra)</a></li>
<li class="toctree-l1"><a class="reference internal" href="aer.html">Qiskit Simulator (Aer)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ignis.html">Qiskit Experiments (Ignis)</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqua.html">Qiskit Application Modules (Aqua)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ibmq-provider.html">Qiskit IBM Quantum (Provider)</a></li>
</ul>
<p><span class="caption-text">Qiskit Applications (Aqua) Migration Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../aqua_migration.html">Qiskit Applications (Aqua) Migration Guide</a></li>
</ul>
<p><span class="caption-text">Rozwiązywanie problemów</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://quantum-computing.ibm.com/docs/cloud/errors">Kody błędów interfejsu IBM Quantum API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="terra.html">Qiskit Terra API Reference</a> &gt;</li>
        
          <li><a href="algorithms.html">Algorithms (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.algorithms</span></code>)</a> &gt;</li>
        
      <li>qiskit.algorithms.optimizers</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            <a href="../_sources/apidoc/qiskit.algorithms.optimizers.rst" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">
          
          <div class="rst-content style-external-links">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <section id="module-qiskit.algorithms.optimizers">
<span id="qiskit-algorithms-optimizers"></span><h1>qiskit.algorithms.optimizers<a class="headerlink" href="#module-qiskit.algorithms.optimizers" title="Stały odnośnik do tego nagłówka">¶</a></h1>
<section id="optimizers-qiskit-algorithms-optimizers">
<h2>Optimizers (<a class="reference internal" href="#module-qiskit.algorithms.optimizers" title="qiskit.algorithms.optimizers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.algorithms.optimizers</span></code></a>)<a class="headerlink" href="#optimizers-qiskit-algorithms-optimizers" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>It  contains a variety of classical optimizers for use by quantum variational algorithms,
such as <a class="reference internal" href="../stubs/qiskit.algorithms.VQE.html#qiskit.algorithms.VQE" title="qiskit.algorithms.VQE"><code class="xref py py-class docutils literal notranslate"><span class="pre">VQE</span></code></a>.
Logically, these optimizers can be divided into two categories:</p>
<dl class="simple">
<dt><a class="reference internal" href="#local-optimizers">Local Optimizers</a></dt><dd><p>Given an optimization problem, a <strong>local optimizer</strong> is a function
that attempts to find an optimal value within the neighboring set of a candidate solution.</p>
</dd>
<dt><a class="reference internal" href="#global-optimizers">Global Optimizers</a></dt><dd><p>Given an optimization problem, a <strong>global optimizer</strong> is a function
that attempts to find an optimal value among all possible solutions.</p>
</dd>
</dl>
</section>
<section id="optimizer-base-class">
<h2>Optimizer Base Class<a class="headerlink" href="#optimizer-base-class" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.OptimizerSupportLevel.html#qiskit.algorithms.optimizers.OptimizerSupportLevel" title="qiskit.algorithms.optimizers.OptimizerSupportLevel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimizerSupportLevel</span></code></a></p></td>
<td><p>Support Level enum for features such as bounds, gradient and initial point</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.Optimizer.html#qiskit.algorithms.optimizers.Optimizer" title="qiskit.algorithms.optimizers.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a></p></td>
<td><p>Base class for optimization algorithm.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="local-optimizers">
<h2>Local Optimizers<a class="headerlink" href="#local-optimizers" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.ADAM.html#qiskit.algorithms.optimizers.ADAM" title="qiskit.algorithms.optimizers.ADAM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ADAM</span></code></a></p></td>
<td><p>Adam and AMSGRAD optimizers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.AQGD.html#qiskit.algorithms.optimizers.AQGD" title="qiskit.algorithms.optimizers.AQGD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AQGD</span></code></a></p></td>
<td><p>Analytic Quantum Gradient Descent (AQGD) with Epochs optimizer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.CG.html#qiskit.algorithms.optimizers.CG" title="qiskit.algorithms.optimizers.CG"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CG</span></code></a></p></td>
<td><p>Conjugate Gradient optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.COBYLA.html#qiskit.algorithms.optimizers.COBYLA" title="qiskit.algorithms.optimizers.COBYLA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">COBYLA</span></code></a></p></td>
<td><p>Constrained Optimization By Linear Approximation optimizer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.L_BFGS_B.html#qiskit.algorithms.optimizers.L_BFGS_B" title="qiskit.algorithms.optimizers.L_BFGS_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L_BFGS_B</span></code></a></p></td>
<td><p>Limited-memory BFGS Bound optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.GSLS.html#qiskit.algorithms.optimizers.GSLS" title="qiskit.algorithms.optimizers.GSLS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GSLS</span></code></a></p></td>
<td><p>Gaussian-smoothed Line Search.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.NELDER_MEAD.html#qiskit.algorithms.optimizers.NELDER_MEAD" title="qiskit.algorithms.optimizers.NELDER_MEAD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NELDER_MEAD</span></code></a></p></td>
<td><p>Nelder-Mead optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.NFT.html#qiskit.algorithms.optimizers.NFT" title="qiskit.algorithms.optimizers.NFT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NFT</span></code></a></p></td>
<td><p>Nakanishi-Fujii-Todo algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.P_BFGS.html#qiskit.algorithms.optimizers.P_BFGS" title="qiskit.algorithms.optimizers.P_BFGS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">P_BFGS</span></code></a></p></td>
<td><p>Parallelized Limited-memory BFGS optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.POWELL.html#qiskit.algorithms.optimizers.POWELL" title="qiskit.algorithms.optimizers.POWELL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">POWELL</span></code></a></p></td>
<td><p>Powell optimizer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.SLSQP.html#qiskit.algorithms.optimizers.SLSQP" title="qiskit.algorithms.optimizers.SLSQP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SLSQP</span></code></a></p></td>
<td><p>Sequential Least SQuares Programming optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.SPSA.html#qiskit.algorithms.optimizers.SPSA" title="qiskit.algorithms.optimizers.SPSA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SPSA</span></code></a></p></td>
<td><p>Simultaneous Perturbation Stochastic Approximation (SPSA) optimizer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.TNC.html#qiskit.algorithms.optimizers.TNC" title="qiskit.algorithms.optimizers.TNC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TNC</span></code></a></p></td>
<td><p>Truncated Newton (TNC) optimizer.</p></td>
</tr>
</tbody>
</table>
<p>Qiskit also provides the following optimizers, which are built-out using the optimizers from
the <cite>scikit-quant</cite> package. The <cite>scikit-quant</cite> package is not installed by default but must be
explicitly installed, if desired, by the user - the optimizers therein are provided under various
licenses so it has been made an optional install for the end user to choose whether to do so or
not. To install the <cite>scikit-quant</cite> dependent package you can use
<cite>pip install scikit-quant</cite>.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.BOBYQA.html#qiskit.algorithms.optimizers.BOBYQA" title="qiskit.algorithms.optimizers.BOBYQA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BOBYQA</span></code></a></p></td>
<td><p>Bound Optimization BY Quadratic Approximation algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.IMFIL.html#qiskit.algorithms.optimizers.IMFIL" title="qiskit.algorithms.optimizers.IMFIL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IMFIL</span></code></a></p></td>
<td><p>IMplicit FILtering algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.SNOBFIT.html#qiskit.algorithms.optimizers.SNOBFIT" title="qiskit.algorithms.optimizers.SNOBFIT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SNOBFIT</span></code></a></p></td>
<td><p>Stable Noisy Optimization by Branch and FIT algorithm.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="global-optimizers">
<h2>Global Optimizers<a class="headerlink" href="#global-optimizers" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>The global optimizers here all use NLopt for their core function and can only be
used if their dependent NLopt package is manually installed. See the following
section for installation instructions.</p>
<div class="toctree-wrapper compound">
</div>
<p>The global optimizers are as follows:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.CRS.html#qiskit.algorithms.optimizers.CRS" title="qiskit.algorithms.optimizers.CRS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CRS</span></code></a></p></td>
<td><p>Controlled Random Search (CRS) with local mutation optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.DIRECT_L.html#qiskit.algorithms.optimizers.DIRECT_L" title="qiskit.algorithms.optimizers.DIRECT_L"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DIRECT_L</span></code></a></p></td>
<td><p>DIviding RECTangles Locally-biased optimizer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.DIRECT_L_RAND.html#qiskit.algorithms.optimizers.DIRECT_L_RAND" title="qiskit.algorithms.optimizers.DIRECT_L_RAND"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DIRECT_L_RAND</span></code></a></p></td>
<td><p>DIviding RECTangles Locally-biased Randomized optimizer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.ESCH.html#qiskit.algorithms.optimizers.ESCH" title="qiskit.algorithms.optimizers.ESCH"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ESCH</span></code></a></p></td>
<td><p>ESCH evolutionary optimizer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.ISRES.html#qiskit.algorithms.optimizers.ISRES" title="qiskit.algorithms.optimizers.ISRES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ISRES</span></code></a></p></td>
<td><p>Improved Stochastic Ranking Evolution Strategy optimizer.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="qiskit.algorithms.optimizers.ADAM">
<em class="property">class </em><code class="sig-name descname">ADAM</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">lr</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">beta_1</span><span class="o">=</span><span class="default_value">0.9</span></em>, <em class="sig-param"><span class="n">beta_2</span><span class="o">=</span><span class="default_value">0.99</span></em>, <em class="sig-param"><span class="n">noise_factor</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">amsgrad</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">snapshot_dir</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/adam_amsgrad.html#ADAM"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Adam and AMSGRAD optimizers.</p>
<p>Adam [1] is a gradient-based optimization algorithm that is relies on adaptive estimates of
lower-order moments. The algorithm requires little memory and is invariant to diagonal
rescaling of the gradients. Furthermore, it is able to cope with non-stationary objective
functions and noisy and/or sparse gradients.</p>
<p>AMSGRAD [2] (a variant of Adam) uses a «long-term memory» of past gradients and, thereby,
improves convergence properties.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1]: Kingma, Diederik &amp; Ba, Jimmy (2014), Adam: A Method for Stochastic Optimization.</dt><dd><p><a class="reference external" href="https://arxiv.org/abs/1412.6980">arXiv:1412.6980</a></p>
</dd>
<dt>[2]: Sashank J. Reddi and Satyen Kale and Sanjiv Kumar (2018),</dt><dd><p>On the Convergence of Adam and Beyond.
<a class="reference external" href="https://arxiv.org/abs/1904.09237">arXiv:1904.09237</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of iterations</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for termination</p></li>
<li><p><strong>lr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Value &gt;= 0, Learning rate.</p></li>
<li><p><strong>beta_1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Value in range 0 to 1, Generally close to 1.</p></li>
<li><p><strong>beta_2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Value in range 0 to 1, Generally close to 1.</p></li>
<li><p><strong>noise_factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Value &gt;= 0, Noise factor</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Value &gt;=0, Epsilon to be used for finite differences if no analytic
gradient method is given.</p></li>
<li><p><strong>amsgrad</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True to use AMSGRAD, False if not</p></li>
<li><p><strong>snapshot_dir</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – If not None save the optimizer’s parameter
after every step to the given directory</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/adam_amsgrad.html#ADAM.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.load_params">
<code class="sig-name descname">load_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">load_dir</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/adam_amsgrad.html#ADAM.load_params"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.load_params" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Load iteration parameters for a file called <code class="docutils literal notranslate"><span class="pre">adam_params.csv</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>load_dir</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The directory containing <code class="docutils literal notranslate"><span class="pre">adam_params.csv</span></code>.</p>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.minimize">
<code class="sig-name descname">minimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">initial_point</span></em>, <em class="sig-param"><span class="n">gradient_function</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/adam_amsgrad.html#ADAM.minimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.minimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Run the minimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>objective_function</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A function handle to the objective function.</p></li>
<li><p><strong>initial_point</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The initial iteration point.</p></li>
<li><p><strong>gradient_function</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A function handle to the gradient of the objective function.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p>A tuple of (optimal parameters, optimal value, number of iterations).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/adam_amsgrad.html#ADAM.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Handle to a function that computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – Handle to a function that computes the gradient of the objective
function.</p></li>
<li><p><strong>variable_bounds</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]) – deprecated</p></li>
<li><p><strong>initial_point</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]) – The initial point for the optimization.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p><p>A tuple (point, value, nfev) where</p>
<blockquote>
<div><p>point: is a 1D numpy.ndarray[float] containing the solution</p>
<p>value: is a float with the objective function value</p>
<p>nfev: is the number of objective function calls</p>
</div></blockquote>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.save_params">
<code class="sig-name descname">save_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">snapshot_dir</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/adam_amsgrad.html#ADAM.save_params"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.save_params" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Save the current iteration parameters to a file called <code class="docutils literal notranslate"><span class="pre">adam_params.csv</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Informacja</p>
<p>The current parameters are appended to the file, if it exists already.
The file is not overwritten.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>snapshot_dir</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The directory to store the file in.</p>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ADAM.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ADAM.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.AQGD">
<em class="property">class </em><code class="sig-name descname">AQGD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">momentum</span><span class="o">=</span><span class="default_value">0.25</span></em>, <em class="sig-param"><span class="n">param_tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">averaging</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/aqgd.html#AQGD"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Analytic Quantum Gradient Descent (AQGD) with Epochs optimizer.
Performs gradient descent optimization with a momentum term, analytic gradients,
and customized step length schedule for parameterized quantum gates, i.e.
Pauli Rotations. See, for example:</p>
<ul class="simple">
<li><p>K. Mitarai, M. Negoro, M. Kitagawa, and K. Fujii. (2018).
Quantum circuit learning. Phys. Rev. A 98, 032309.
<a class="reference external" href="https://arxiv.org/abs/1803.00745">https://arxiv.org/abs/1803.00745</a></p></li>
<li><p>Maria Schuld, Ville Bergholm, Christian Gogolin, Josh Izaac, Nathan Killoran. (2019).
Evaluating analytic gradients on quantum hardware. Phys. Rev. A 99, 032331.
<a class="reference external" href="https://arxiv.org/abs/1811.11184">https://arxiv.org/abs/1811.11184</a></p></li>
</ul>
<p>for further details on analytic gradients of parameterized quantum gates.</p>
<p>Gradients are computed „analytically” using the quantum circuit when evaluating
the objective function.</p>
<p>Performs Analytical Quantum Gradient Descent (AQGD) with Epochs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – Maximum number of iterations (full gradient steps)</p></li>
<li><p><strong>eta</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – The coefficient of the gradient update. Increasing this value
results in larger step sizes: param = previous_param - eta * deriv</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for change in windowed average of objective values.
Convergence occurs when either objective tolerance is met OR parameter
tolerance is met.</p></li>
<li><p><strong>momentum</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – Bias towards the previous gradient momentum in current
update. Must be within the bounds: [0,1)</p></li>
<li><p><strong>param_tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for change in norm of parameters.</p></li>
<li><p><strong>averaging</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Length of window over which to average objective values for objective
convergence criterion</p></li>
</ul>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.algorithms.AlgorithmError.html#qiskit.algorithms.AlgorithmError" title="qiskit.algorithms.AlgorithmError"><strong>AlgorithmError</strong></a> – If the length of <code class="docutils literal notranslate"><span class="pre">maxiter</span></code>, <cite>momentum`</cite>, and <code class="docutils literal notranslate"><span class="pre">eta</span></code> is not the same.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/aqgd.html#AQGD.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Support level dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>gradient, bounds and initial point</dt><dd><p>support information that is ignored/required.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p>Dict[str, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/aqgd.html#AQGD.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.AQGD.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.AQGD.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.BOBYQA">
<em class="property">class </em><code class="sig-name descname">BOBYQA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/bobyqa.html#BOBYQA"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Bound Optimization BY Quadratic Approximation algorithm.</p>
<p>BOBYQA finds local solutions to nonlinear, non-convex minimization problems with optional
bound constraints, without requirement of derivatives of the objective function.</p>
<p>Uses skquant.opt installed with pip install scikit-quant.
For further detail, please refer to
<a class="reference external" href="https://github.com/scikit-quant/scikit-quant">https://github.com/scikit-quant/scikit-quant</a> and <a class="reference external" href="https://qat4chem.lbl.gov/software">https://qat4chem.lbl.gov/software</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – scikit-quant not installed</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/bobyqa.html#BOBYQA.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns support level dictionary.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/bobyqa.html#BOBYQA.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Runs the optimization.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.BOBYQA.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.BOBYQA.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.CG">
<em class="property">class </em><code class="sig-name descname">CG</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">gtol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1.4901161193847656e-08</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/cg.html#CG"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.CG" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Conjugate Gradient optimizer.</p>
<p>CG is an algorithm for the numerical solution of systems of linear equations whose matrices are
symmetric and positive-definite. It is an <em>iterative algorithm</em> in that it uses an initial
guess to generate a sequence of improving approximate solutions for a problem,
in which each approximation is derived from the previous ones.  It is often used to solve
unconstrained optimization problems, such as energy minimization.</p>
<p>Uses scipy.optimize.minimize CG.
For further detail, please refer to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of iterations to perform.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to print convergence messages.</p></li>
<li><p><strong>gtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Gradient norm must be less than gtol before successful termination.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Tolerance for termination.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – If jac is approximated, use this value for the step size.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/cg.html#CG.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/cg.html#CG.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CG.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CG.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.COBYLA">
<em class="property">class </em><code class="sig-name descname">COBYLA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rhobeg</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/cobyla.html#COBYLA"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Constrained Optimization By Linear Approximation optimizer.</p>
<p>COBYLA is a numerical optimization method for constrained problems
where the derivative of the objective function is not known.</p>
<p>Uses scipy.optimize.minimize COBYLA.
For further detail, please refer to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to print convergence messages.</p></li>
<li><p><strong>rhobeg</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Reasonable initial changes to the variables.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Final accuracy in the optimization (not precisely guaranteed).
This is a lower bound on the size of the trust region.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/cobyla.html#COBYLA.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/cobyla.html#COBYLA.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.COBYLA.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.COBYLA.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.CRS">
<em class="property">class </em><code class="sig-name descname">CRS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_evals</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/crs.html#CRS"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Controlled Random Search (CRS) with local mutation optimizer.</p>
<p>Controlled Random Search (CRS) with local mutation is part of the family of the CRS optimizers.
The CRS optimizers start with a random population of points, and randomly evolve these points
by heuristic rules. In the case of CRS with local mutation, the evolution is a randomized
version of the <a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.NELDER_MEAD.html#qiskit.algorithms.optimizers.NELDER_MEAD" title="qiskit.algorithms.optimizers.NELDER_MEAD"><code class="xref py py-class docutils literal notranslate"><span class="pre">NELDER_MEAD</span></code></a> local optimizer.</p>
<p>NLopt global optimizer, derivative-free.
For further detail, please refer to
<a class="reference external" href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#controlled-random-search-crs-with-local-mutation">https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#controlled-random-search-crs-with-local-mutation</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>max_evals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – NLopt library not installed.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.get_nlopt_optimizer">
<code class="sig-name descname">get_nlopt_optimizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/crs.html#CRS.get_nlopt_optimizer"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.get_nlopt_optimizer" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return NLopt optimizer type</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NLoptOptimizerType</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.CRS.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.CRS.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.DIRECT_L">
<em class="property">class </em><code class="sig-name descname">DIRECT_L</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_evals</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/direct_l.html#DIRECT_L"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>DIviding RECTangles Locally-biased optimizer.</p>
<p>DIviding RECTangles (DIRECT) is a deterministic-search algorithms based on systematic division
of the search domain into increasingly smaller hyper-rectangles.
The DIRECT-L version is a „locally biased” variant of DIRECT that makes the algorithm more
biased towards local search, so that it is more efficient for functions with few local minima.</p>
<p>NLopt global optimizer, derivative-free.
For further detail, please refer to
<a class="reference external" href="http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#direct-and-direct-l">http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#direct-and-direct-l</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>max_evals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – NLopt library not installed.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.get_nlopt_optimizer">
<code class="sig-name descname">get_nlopt_optimizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/direct_l.html#DIRECT_L.get_nlopt_optimizer"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.get_nlopt_optimizer" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return NLopt optimizer type</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NLoptOptimizerType</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND">
<em class="property">class </em><code class="sig-name descname">DIRECT_L_RAND</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_evals</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/direct_l_rand.html#DIRECT_L_RAND"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>DIviding RECTangles Locally-biased Randomized optimizer.</p>
<p>DIRECT-L RAND is the „locally biased” variant with some randomization in near-tie decisions.
See also <a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.DIRECT_L.html#qiskit.algorithms.optimizers.DIRECT_L" title="qiskit.algorithms.optimizers.DIRECT_L"><code class="xref py py-class docutils literal notranslate"><span class="pre">DIRECT_L</span></code></a></p>
<p>NLopt global optimizer, derivative-free.
For further detail, please refer to
<a class="reference external" href="http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#direct-and-direct-l">http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#direct-and-direct-l</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>max_evals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – NLopt library not installed.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.get_nlopt_optimizer">
<code class="sig-name descname">get_nlopt_optimizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/direct_l_rand.html#DIRECT_L_RAND.get_nlopt_optimizer"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.get_nlopt_optimizer" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return NLopt optimizer type</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NLoptOptimizerType</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.DIRECT_L_RAND.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.DIRECT_L_RAND.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.ESCH">
<em class="property">class </em><code class="sig-name descname">ESCH</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_evals</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/esch.html#ESCH"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>ESCH evolutionary optimizer.</p>
<p>ESCH is an evolutionary algorithm for global optimization that supports bound constraints only.
Specifically, it does not support nonlinear constraints.</p>
<p>NLopt global optimizer, derivative-free.
For further detail, please refer to</p>
<p><a class="reference external" href="http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#esch-evolutionary-algorithm">http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#esch-evolutionary-algorithm</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>max_evals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – NLopt library not installed.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.get_nlopt_optimizer">
<code class="sig-name descname">get_nlopt_optimizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/esch.html#ESCH.get_nlopt_optimizer"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.get_nlopt_optimizer" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return NLopt optimizer type</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NLoptOptimizerType</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ESCH.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ESCH.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.GSLS">
<em class="property">class </em><code class="sig-name descname">GSLS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">max_eval</span><span class="o">=</span><span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sampling_radius</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">sample_size_factor</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_step_size</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">min_step_size</span><span class="o">=</span><span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">step_size_multiplier</span><span class="o">=</span><span class="default_value">0.4</span></em>, <em class="sig-param"><span class="n">armijo_parameter</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">min_gradient_norm</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">max_failed_rejection_sampling</span><span class="o">=</span><span class="default_value">50</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Gaussian-smoothed Line Search.</p>
<p>An implementation of the line search algorithm described in
<a class="reference external" href="https://arxiv.org/pdf/1905.01332.pdf">https://arxiv.org/pdf/1905.01332.pdf</a>, using gradient approximation
based on Gaussian-smoothed samples on a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of iterations.</p></li>
<li><p><strong>max_eval</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of evaluations.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to display convergence messages.</p></li>
<li><p><strong>sampling_radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Sampling radius to determine gradient estimate.</p></li>
<li><p><strong>sample_size_factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The size of the sample set at each iteration is this number
multiplied by the dimension of the problem, rounded to the nearest integer.</p></li>
<li><p><strong>initial_step_size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Initial step size for the descent algorithm.</p></li>
<li><p><strong>min_step_size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Minimum step size for the descent algorithm.</p></li>
<li><p><strong>step_size_multiplier</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Step size reduction after unsuccessful steps, in the
interval (0, 1).</p></li>
<li><p><strong>armijo_parameter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Armijo parameter for sufficient decrease criterion, in the
interval (0, 1).</p></li>
<li><p><strong>min_gradient_norm</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – If the gradient norm is below this threshold, the algorithm stops.</p></li>
<li><p><strong>max_failed_rejection_sampling</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of attempts to sample points within
bounds.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>A dictionary containing the support levels for different options.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.gradient_approximation">
<code class="sig-name descname">gradient_approximation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">x_value</span></em>, <em class="sig-param"><span class="n">directions</span></em>, <em class="sig-param"><span class="n">sample_set_x</span></em>, <em class="sig-param"><span class="n">sample_set_y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS.gradient_approximation"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.gradient_approximation" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Construct gradient approximation from given sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Dimension of the problem.</p></li>
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Point around which the sample set was constructed.</p></li>
<li><p><strong>x_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Objective function value at x.</p></li>
<li><p><strong>directions</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Directions of the sample points wrt the central point x, as a 2D array.</p></li>
<li><p><strong>sample_set_x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – x-coordinates of the sample set, one point per row, as a 2D array.</p></li>
<li><p><strong>sample_set_y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Objective function values of the points in sample_set_x, as a 1D array.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p>Gradient approximation at x, as a 1D array.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.ls_optimize">
<code class="sig-name descname">ls_optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">obj_fun</span></em>, <em class="sig-param"><span class="n">initial_point</span></em>, <em class="sig-param"><span class="n">var_lb</span></em>, <em class="sig-param"><span class="n">var_ub</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS.ls_optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.ls_optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Run the line search optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Dimension of the problem.</p></li>
<li><p><strong>obj_fun</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>) – Objective function.</p></li>
<li><p><strong>initial_point</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Initial point.</p></li>
<li><p><strong>var_lb</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Vector of lower bounds on the decision variables. Vector elements can be -np.inf
if the corresponding variable is unbounded from below.</p></li>
<li><p><strong>var_ub</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Vector of upper bounds on the decision variables. Vector elements can be np.inf
if the corresponding variable is unbounded from below.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p>Final iterate as a vector, corresponding objective function value,
number of evaluations, and norm of the gradient estimate.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of dimensions mismatches the size of the initial point or
    the length of the lower or upper bound.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.sample_points">
<code class="sig-name descname">sample_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">num_points</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS.sample_points"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.sample_points" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sample <code class="docutils literal notranslate"><span class="pre">num_points</span></code> points around <code class="docutils literal notranslate"><span class="pre">x</span></code> on the <code class="docutils literal notranslate"><span class="pre">n</span></code>-sphere of specified radius.</p>
<p>The radius of the sphere is <code class="docutils literal notranslate"><span class="pre">self._options['sampling_radius']</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Dimension of the problem.</p></li>
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Point around which the sample set is constructed.</p></li>
<li><p><strong>num_points</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of points in the sample set.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p>A tuple containing the sampling points and the directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.sample_set">
<code class="sig-name descname">sample_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">var_lb</span></em>, <em class="sig-param"><span class="n">var_ub</span></em>, <em class="sig-param"><span class="n">num_points</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/gsls.html#GSLS.sample_set"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.sample_set" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Construct sample set of given size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Dimension of the problem.</p></li>
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Point around which the sample set is constructed.</p></li>
<li><p><strong>var_lb</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Vector of lower bounds on the decision variables. Vector elements can be -np.inf
if the corresponding variable is unbounded from below.</p></li>
<li><p><strong>var_ub</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Vector of lower bounds on the decision variables. Vector elements can be np.inf
if the corresponding variable is unbounded from above.</p></li>
<li><p><strong>num_points</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of points in the sample set.</p></li>
</ul>
</dd>
<dt class="field-even">Typ zwracany</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
<dt class="field-odd">Zwraca</dt>
<dd class="field-odd"><p>Matrices of (unit-norm) sample directions and sample points, one per row.
Both matrices are 2D arrays of floats.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If not enough samples could be generated within the bounds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.GSLS.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.GSLS.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.IMFIL">
<em class="property">class </em><code class="sig-name descname">IMFIL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/imfil.html#IMFIL"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>IMplicit FILtering algorithm.</p>
<p>Implicit filtering is a way to solve bound-constrained optimization problems for
which derivatives are not available. In comparison to methods that use interpolation to
reconstruct the function and its higher derivatives, implicit filtering builds upon
coordinate search followed by interpolation to get an approximate gradient.</p>
<p>Uses skquant.opt installed with pip install scikit-quant.
For further detail, please refer to
<a class="reference external" href="https://github.com/scikit-quant/scikit-quant">https://github.com/scikit-quant/scikit-quant</a> and <a class="reference external" href="https://qat4chem.lbl.gov/software">https://qat4chem.lbl.gov/software</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – scikit-quant not installed</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/imfil.html#IMFIL.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns support level dictionary.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/imfil.html#IMFIL.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Runs the optimization.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.IMFIL.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.IMFIL.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.ISRES">
<em class="property">class </em><code class="sig-name descname">ISRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_evals</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/isres.html#ISRES"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Improved Stochastic Ranking Evolution Strategy optimizer.</p>
<p>Improved Stochastic Ranking Evolution Strategy (ISRES) is an algorithm for
non-linearly constrained global optimization. It has heuristics to escape local optima,
even though convergence to a global optima is not guaranteed. The evolution strategy is based
on a combination of a mutation rule and differential variation. The fitness ranking is simply
via the objective function for problems without nonlinear constraints. When nonlinear
constraints are included, the <a class="reference external" href="https://notendur.hi.is/tpr/software/sres/Tec311r.pdf">stochastic ranking proposed by Runarsson and Yao</a>
is employed. This method supports arbitrary nonlinear inequality and equality constraints, in
addition to the bound constraints.</p>
<p>NLopt global optimizer, derivative-free.
For further detail, please refer to
<a class="reference external" href="http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#isres-improved-stochastic-ranking-evolution-strategy">http://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#isres-improved-stochastic-ranking-evolution-strategy</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>max_evals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations.</p>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – NLopt library not installed.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.get_nlopt_optimizer">
<code class="sig-name descname">get_nlopt_optimizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nlopts/isres.html#ISRES.get_nlopt_optimizer"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.get_nlopt_optimizer" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return NLopt optimizer type</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NLoptOptimizerType</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.ISRES.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.ISRES.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B">
<em class="property">class </em><code class="sig-name descname">L_BFGS_B</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxfun</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">15000</span></em>, <em class="sig-param"><span class="n">factr</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">iprint</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/l_bfgs_b.html#L_BFGS_B"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Limited-memory BFGS Bound optimizer.</p>
<p>The target goal of Limited-memory Broyden-Fletcher-Goldfarb-Shanno Bound (L-BFGS-B)
is to minimize the value of a differentiable scalar function <span class="math notranslate nohighlight">\(f\)</span>.
This optimizer is a quasi-Newton method, meaning that, in contrast to Newtons’s method,
it does not require <span class="math notranslate nohighlight">\(f\)</span>’s Hessian (the matrix of <span class="math notranslate nohighlight">\(f\)</span>’s second derivatives)
when attempting to compute <span class="math notranslate nohighlight">\(f\)</span>’s minimum value.</p>
<p>Like BFGS, L-BFGS is an iterative method for solving unconstrained, non-linear optimization
problems, but approximates BFGS using a limited amount of computer memory.
L-BFGS starts with an initial estimate of the optimal value, and proceeds iteratively
to refine that estimate with a sequence of better estimates.</p>
<p>The derivatives of <span class="math notranslate nohighlight">\(f\)</span> are used to identify the direction of steepest descent,
and also to form an estimate of the Hessian matrix (second derivative) of <span class="math notranslate nohighlight">\(f\)</span>.
L-BFGS-B extends L-BFGS to handle simple, per-variable bound constraints.</p>
<p>Uses scipy.optimize.fmin_l_bfgs_b.
For further detail, please refer to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxfun</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations.</p></li>
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of iterations.</p></li>
<li><p><strong>factr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The iteration stops when (f^k - f^{k+1})/max{|f^k|,
|f^{k+1}|,1} &lt;= factr * eps, where eps is the machine precision,
which is automatically generated by the code. Typical values for
factr are: 1e12 for low accuracy; 1e7 for moderate accuracy;
10.0 for extremely high accuracy. See Notes for relationship to ftol,
which is exposed (instead of factr) by the scipy.optimize.minimize
interface to L-BFGS-B.</p></li>
<li><p><strong>iprint</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Controls the frequency of output. iprint &lt; 0 means no output;
iprint = 0 print only one line at the last iteration; 0 &lt; iprint &lt; 99
print also f and |proj g| every iprint iterations; iprint = 99 print
details of every iteration except n-vectors; iprint = 100 print also the
changes of active set and final x; iprint &gt; 100 print details of
every iteration including x and g.</p></li>
<li><p><strong>epsilon</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Step size used when approx_grad is True, for numerically
calculating the gradient</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/l_bfgs_b.html#L_BFGS_B.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/l_bfgs_b.html#L_BFGS_B.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.L_BFGS_B.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.L_BFGS_B.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD">
<em class="property">class </em><code class="sig-name descname">NELDER_MEAD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxfev</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">xatol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">adaptive</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nelder_mead.html#NELDER_MEAD"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Nelder-Mead optimizer.</p>
<p>The Nelder-Mead algorithm performs unconstrained optimization; it ignores bounds
or constraints.  It is used to find the minimum or maximum of an objective function
in a multidimensional space.  It is based on the Simplex algorithm. Nelder-Mead
is robust in many applications, especially when the first and second derivatives of the
objective function are not known.</p>
<p>However, if the numerical computation of the derivatives can be trusted to be accurate,
other algorithms using the first and/or second derivatives information might be preferred to
Nelder-Mead for their better performance in the general case, especially in consideration of
the fact that the Nelder–Mead technique is a heuristic search method that can converge to
non-stationary points.</p>
<p>Uses scipy.optimize.minimize Nelder-Mead.
For further detail, please refer to
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – Maximum allowed number of iterations. If both maxiter and maxfev are set,
minimization will stop at the first reached.</p></li>
<li><p><strong>maxfev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations. If both maxiter and
maxfev are set, minimization will stop at the first reached.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to print convergence messages.</p></li>
<li><p><strong>xatol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute error in xopt between iterations that is acceptable for convergence.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Tolerance for termination.</p></li>
<li><p><strong>adaptive</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Adapt algorithm parameters to dimensionality of problem.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nelder_mead.html#NELDER_MEAD.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nelder_mead.html#NELDER_MEAD.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NELDER_MEAD.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NELDER_MEAD.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.NFT">
<em class="property">class </em><code class="sig-name descname">NFT</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxfev</span><span class="o">=</span><span class="default_value">1024</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reset_interval</span><span class="o">=</span><span class="default_value">32</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nft.html#NFT"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Nakanishi-Fujii-Todo algorithm.</p>
<p>See <a class="reference external" href="https://arxiv.org/abs/1903.12166">https://arxiv.org/abs/1903.12166</a></p>
<p>Built out using scipy framework, for details, please refer to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – Maximum number of iterations to perform.</p></li>
<li><p><strong>maxfev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations to perform.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – disp</p></li>
<li><p><strong>reset_interval</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The minimum estimates directly once
in <code class="docutils literal notranslate"><span class="pre">reset_interval</span></code> times.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Uwagi</p>
<p>In this optimization method, the optimization function have to satisfy
three conditions written in <a class="footnote-reference brackets" href="#id2" id="id1">1</a>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>K. M. Nakanishi, K. Fujii, and S. Todo. 2019.
Sequential minimal optimization for quantum-classical hybrid algorithms.
arXiv preprint arXiv:1903.12166.</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nft.html#NFT.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/nft.html#NFT.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.NFT.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.NFT.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.Optimizer">
<em class="property">class </em><code class="sig-name descname">Optimizer</code><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Base class for optimization algorithm.</p>
<p>Initialize the optimization algorithm, setting the support
level for _gradient_support_level, _bound_support_level,
_initial_point_support_level, and empty options.</p>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.get_support_level">
<em class="property">abstract </em><code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.gradient_num_diff"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.optimize">
<em class="property">abstract </em><code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.print_options"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.set_max_evals_grouped"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.set_options"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.Optimizer.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#Optimizer.wrap_function"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.Optimizer.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.OptimizerSupportLevel">
<em class="property">class </em><code class="sig-name descname">OptimizerSupportLevel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/optimizer.html#OptimizerSupportLevel"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.OptimizerSupportLevel" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Support Level enum for features such as bounds, gradient and initial point</p>
</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.POWELL">
<em class="property">class </em><code class="sig-name descname">POWELL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxfev</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">xtol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/powell.html#POWELL"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Powell optimizer.</p>
<p>The Powell algorithm performs unconstrained optimization; it ignores bounds or
constraints. Powell is a <em>conjugate direction method</em>: it performs sequential one-dimensional
minimization along each directional vector, which is updated at
each iteration of the main minimization loop. The function being minimized need not be
differentiable, and no derivatives are taken.</p>
<p>Uses scipy.optimize.minimize Powell.
For further detail, please refer to
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – Maximum allowed number of iterations. If both maxiter and maxfev
are set, minimization will stop at the first reached.</p></li>
<li><p><strong>maxfev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum allowed number of function evaluations. If both maxiter and
maxfev are set, minimization will stop at the first reached.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to print convergence messages.</p></li>
<li><p><strong>xtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative error in solution xopt acceptable for convergence.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Tolerance for termination.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/powell.html#POWELL.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/powell.html#POWELL.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.POWELL.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.POWELL.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.P_BFGS">
<em class="property">class </em><code class="sig-name descname">P_BFGS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxfun</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">factr</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">iprint</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">max_processes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/p_bfgs.html#P_BFGS"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Parallelized Limited-memory BFGS optimizer.</p>
<p>P-BFGS is a parallelized version of <a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.L_BFGS_B.html#qiskit.algorithms.optimizers.L_BFGS_B" title="qiskit.algorithms.optimizers.L_BFGS_B"><code class="xref py py-class docutils literal notranslate"><span class="pre">L_BFGS_B</span></code></a> with which it shares the same parameters.
P-BFGS can be useful when the target hardware is a quantum simulator running on a classical
machine. This allows the multiple processes to use simulation to potentially reach a minimum
faster. The parallelization may also help the optimizer avoid getting stuck at local optima.</p>
<p>Uses scipy.optimize.fmin_l_bfgs_b.
For further detail, please refer to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxfun</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations.</p></li>
<li><p><strong>factr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The iteration stops when (f^k - f^{k+1})/max{|f^k|,
|f^{k+1}|,1} &lt;= factr * eps, where eps is the machine precision,
which is automatically generated by the code. Typical values for
factr are: 1e12 for low accuracy; 1e7 for moderate accuracy;
10.0 for extremely high accuracy. See Notes for relationship to ftol,
which is exposed (instead of factr) by the scipy.optimize.minimize
interface to L-BFGS-B.</p></li>
<li><p><strong>iprint</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Controls the frequency of output. iprint &lt; 0 means no output;
iprint = 0 print only one line at the last iteration; 0 &lt; iprint &lt; 99
print also f and |proj g| every iprint iterations; iprint = 99 print
details of every iteration except n-vectors; iprint = 100 print also the
changes of active set and final x; iprint &gt; 100 print details of
every iteration including x and g.</p></li>
<li><p><strong>max_processes</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – maximum number of processes allowed, has a min. value of 1 if not None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/p_bfgs.html#P_BFGS.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/p_bfgs.html#P_BFGS.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.P_BFGS.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.P_BFGS.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.SLSQP">
<em class="property">class </em><code class="sig-name descname">SLSQP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ftol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1.4901161193847656e-08</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/slsqp.html#SLSQP"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sequential Least SQuares Programming optimizer.</p>
<p>SLSQP minimizes a function of several variables with any combination of bounds, equality
and inequality constraints. The method wraps the SLSQP Optimization subroutine originally
implemented by Dieter Kraft.</p>
<p>SLSQP is ideal for mathematical problems for which the objective function and the constraints
are twice continuously differentiable. Note that the wrapper handles infinite values in bounds
by converting them into large floating values.</p>
<p>Uses scipy.optimize.minimize SLSQP.
For further detail, please refer to
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of iterations.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to print convergence messages.</p></li>
<li><p><strong>ftol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Precision goal for the value of f in the stopping criterion.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Tolerance for termination.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Step size used for numerical approximation of the Jacobian.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/slsqp.html#SLSQP.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/slsqp.html#SLSQP.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SLSQP.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SLSQP.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.SNOBFIT">
<em class="property">class </em><code class="sig-name descname">SNOBFIT</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">maxfail</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">maxmp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/snobfit.html#SNOBFIT"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Stable Noisy Optimization by Branch and FIT algorithm.</p>
<p>SnobFit is used for the optimization of derivative-free, noisy objective functions providing
robust and fast solutions of problems with continuous variables varying within bound.</p>
<p>Uses skquant.opt installed with pip install scikit-quant.
For further detail, please refer to
<a class="reference external" href="https://github.com/scikit-quant/scikit-quant">https://github.com/scikit-quant/scikit-quant</a> and <a class="reference external" href="https://qat4chem.lbl.gov/software">https://qat4chem.lbl.gov/software</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluations.</p></li>
<li><p><strong>maxmp</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – Maximum number of  model points requested for the local fit.
Default = 2 * number of parameters + 6 set to this value when None.</p></li>
<li><p><strong>maxfail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of failures to improve the solution. Stops the algorithm
after maxfail is reached.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Provide verbose (debugging) output.</p></li>
</ul>
</dd>
<dt class="field-even">Wyrzuca</dt>
<dd class="field-even"><p><a class="reference internal" href="../stubs/qiskit.aqua.MissingOptionalLibraryError.html#qiskit.aqua.MissingOptionalLibraryError" title="qiskit.aqua.MissingOptionalLibraryError"><strong>MissingOptionalLibraryError</strong></a> – scikit-quant or SQSnobFit not installed</p>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/snobfit.html#SNOBFIT.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns support level dictionary.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/snobfit.html#SNOBFIT.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Runs the optimization.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SNOBFIT.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SNOBFIT.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.SPSA">
<em class="property">class </em><code class="sig-name descname">SPSA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">blocking</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">allowed_increase</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">trust_region</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">learning_rate</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">perturbation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">last_avg</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">resamplings</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">perturbation_dims</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">callback</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/spsa.html#SPSA"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Simultaneous Perturbation Stochastic Approximation (SPSA) optimizer.</p>
<p>SPSA [1] is an algorithmic method for optimizing systems with multiple unknown parameters.
As an optimization method, it is appropriately suited to large-scale population models,
adaptive modeling, and simulation optimization.</p>
<div class="admonition seealso">
<p class="admonition-title">Zobacz także</p>
<p>Many examples are presented at the <a class="reference external" href="http://www.jhuapl.edu/SPSA">SPSA Web site</a>.</p>
</div>
<p>SPSA is a descent method capable of finding global minima,
sharing this property with other methods as simulated annealing.
Its main feature is the gradient approximation, which requires only two
measurements of the objective function, regardless of the dimension of the optimization
problem.</p>
<div class="admonition note">
<p class="admonition-title">Informacja</p>
<p>SPSA can be used in the presence of noise, and it is therefore indicated in situations
involving measurement uncertainty on a quantum computation when finding a minimum.
If you are executing a variational algorithm using a Quantum ASseMbly Language (QASM)
simulator or a real device, SPSA would be the most recommended choice among the optimizers
provided here.</p>
</div>
<p>The optimization process can includes a calibration phase if neither the <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> nor
<code class="docutils literal notranslate"><span class="pre">perturbation</span></code> is provided, which requires additional functional evaluations.
(Note that either both or none must be set.) For further details on the automatic calibration,
please refer to the supplementary information section IV. of [2].</p>
<p class="rubric">References</p>
<p>[1]: J. C. Spall (1998). An Overview of the Simultaneous Perturbation Method for Efficient
Optimization, Johns Hopkins APL Technical Digest, 19(4), 482–492.
<a class="reference external" href="https://www.jhuapl.edu/SPSA/PDF-SPSA/Spall_An_Overview.PDF">Online.</a></p>
<p>[2]: A. Kandala et al. (2017). Hardware-efficient Variational Quantum Eigensolver for
Small Molecules and Quantum Magnets. Nature 549, pages242–246(2017).
<a class="reference external" href="https://arxiv.org/pdf/1704.05018v2.pdf#section*.11">arXiv:1704.05018v2</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The maximum number of iterations.</p></li>
<li><p><strong>blocking</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, only accepts updates that improve the loss (minus some allowed
increase, see next argument).</p></li>
<li><p><strong>allowed_increase</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – If blocking is True, this sets by how much the loss can increase
and still be accepted. If None, calibrated automatically to be twice the
standard deviation of the loss function.</p></li>
<li><p><strong>trust_region</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, restricts norm of the random direction to be <span class="math notranslate nohighlight">\(\leq 1\)</span>.</p></li>
<li><p><strong>learning_rate</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[], <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator</span></code>], <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – A generator yielding learning rates for the parameter updates,
<span class="math notranslate nohighlight">\(a_k\)</span>. If set, also <code class="docutils literal notranslate"><span class="pre">perturbation</span></code> must be provided.</p></li>
<li><p><strong>perturbation</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[], <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator</span></code>], <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – A generator yielding the perturbation magnitudes <span class="math notranslate nohighlight">\(c_k\)</span>. If set,
also <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> must be provided.</p></li>
<li><p><strong>last_avg</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Return the average of the <code class="docutils literal notranslate"><span class="pre">last_avg</span></code> parameters instead of just the
last parameter values.</p></li>
<li><p><strong>resamplings</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – The number of times the gradient is sampled using a random direction to
construct a gradient estimate. Per default the gradient is estimated using only
one random direction. If an integer, all iterations use the same number of
resamplings. If a dictionary, this is interpreted as
<code class="docutils literal notranslate"><span class="pre">{iteration:</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">resamplings</span> <span class="pre">per</span> <span class="pre">iteration}</span></code>.</p></li>
<li><p><strong>perturbation_dims</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – The number of perturbed dimensions. Per default, all dimensions
are perturbed, but a smaller, fixed number can be perturbed. If set, the perturbed
dimensions are chosen uniformly at random.</p></li>
<li><p><strong>callback</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>], <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]]) – A callback function passed information in each iteration step. The
information is, in this order: the parameters, the function value, the number
of function evaluations, the stepsize, whether the step was accepted.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.calibrate">
<em class="property">static </em><code class="sig-name descname">calibrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loss</span></em>, <em class="sig-param"><span class="n">initial_point</span></em>, <em class="sig-param"><span class="n">c</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">stability_constant</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">target_magnitude</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.602</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">0.101</span></em>, <em class="sig-param"><span class="n">modelspace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/spsa.html#SPSA.calibrate"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.calibrate" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Calibrate SPSA parameters with a powerseries as learning rate and perturbation coeffs.</p>
<p>The powerseries are:</p>
<div class="math notranslate nohighlight">
\[a_k = \frac{a}{(A + k + 1)^\alpha}, c_k = \frac{c}{(k + 1)^\gamma}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – The loss function.</p></li>
<li><p><strong>initial_point</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The initial guess of the iteration.</p></li>
<li><p><strong>c</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The initial perturbation magnitude.</p></li>
<li><p><strong>stability_constant</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The value of <cite>A</cite>.</p></li>
<li><p><strong>target_magnitude</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – The target magnitude for the first update step, defaults to
<span class="math notranslate nohighlight">\(2\pi / 10\)</span>.</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The exponent of the learning rate powerseries.</p></li>
<li><p><strong>gamma</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The exponent of the perturbation powerseries.</p></li>
<li><p><strong>modelspace</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether the target magnitude is the difference of parameter values
or function values (= model space).</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple of powerseries generators, the first one for the</dt><dd><p>learning rate and the second one for the perturbation.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>tuple(generator, generator)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.estimate_stddev">
<em class="property">static </em><code class="sig-name descname">estimate_stddev</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loss</span></em>, <em class="sig-param"><span class="n">initial_point</span></em>, <em class="sig-param"><span class="n">avg</span><span class="o">=</span><span class="default_value">25</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/spsa.html#SPSA.estimate_stddev"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.estimate_stddev" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Estimate the standard deviation of the loss function.</p>
<dl class="field-list simple">
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/spsa.html#SPSA.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Get the support level dictionary.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/spsa.html#SPSA.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.SPSA.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.SPSA.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qiskit.algorithms.optimizers.TNC">
<em class="property">class </em><code class="sig-name descname">TNC</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">accuracy</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ftol</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">xtol</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">gtol</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/tnc.html#TNC"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Truncated Newton (TNC) optimizer.</p>
<p>TNC uses a truncated Newton algorithm to minimize a function with variables subject to bounds.
This algorithm uses gradient information; it is also called Newton Conjugate-Gradient.
It differs from the <a class="reference internal" href="../stubs/qiskit.algorithms.optimizers.CG.html#qiskit.algorithms.optimizers.CG" title="qiskit.algorithms.optimizers.CG"><code class="xref py py-class docutils literal notranslate"><span class="pre">CG</span></code></a> method as it wraps a C implementation and allows each variable
to be given upper and lower bounds.</p>
<p>Uses scipy.optimize.minimize TNC
For further detail, please refer to
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of function evaluation.</p></li>
<li><p><strong>disp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set to True to print convergence messages.</p></li>
<li><p><strong>accuracy</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative precision for finite difference calculations.
If &lt;= machine_precision, set to sqrt(machine_precision). Defaults to 0.</p></li>
<li><p><strong>ftol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Precision goal for the value of f in the stopping criterion.
If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1.</p></li>
<li><p><strong>xtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Precision goal for the value of x in the stopping criterion
(after applying x scaling factors).
If xtol &lt; 0.0, xtol is set to sqrt(machine_precision). Defaults to -1.</p></li>
<li><p><strong>gtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Precision goal for the value of the projected gradient in
the stopping criterion (after applying x scaling factors).
If gtol &lt; 0.0, gtol is set to 1e-2 * sqrt(accuracy).
Setting it to 0.0 is not recommended. Defaults to -1.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Tolerance for termination.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Step size used for numerical approximation of the Jacobian.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.bounds_support_level">
<em class="property">property </em><code class="sig-name descname">bounds_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.bounds_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns bounds support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.get_support_level">
<code class="sig-name descname">get_support_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/tnc.html#TNC.get_support_level"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.get_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>return support level dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.gradient_num_diff">
<em class="property">static </em><code class="sig-name descname">gradient_num_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_center</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">epsilon</span></em>, <em class="sig-param"><span class="n">max_evals_grouped</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.gradient_num_diff" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>We compute the gradient with the numeric differentiation in the parallel way,
around the point x_center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_center</strong> (<em>ndarray</em>) – point around which we compute the gradient</p></li>
<li><p><strong>f</strong> (<em>func</em>) – the function of which the gradient is to be computed.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – the epsilon used in the numeric differentiation.</p></li>
<li><p><strong>max_evals_grouped</strong> (<em>int</em>) – max evals grouped</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>the gradient computed</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>grad</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.gradient_support_level">
<em class="property">property </em><code class="sig-name descname">gradient_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.gradient_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns gradient support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.initial_point_support_level">
<em class="property">property </em><code class="sig-name descname">initial_point_support_level</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.initial_point_support_level" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns initial point support level</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_bounds_ignored">
<em class="property">property </em><code class="sig-name descname">is_bounds_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_bounds_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_bounds_required">
<em class="property">property </em><code class="sig-name descname">is_bounds_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_bounds_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_bounds_supported">
<em class="property">property </em><code class="sig-name descname">is_bounds_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_bounds_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is bounds supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_gradient_ignored">
<em class="property">property </em><code class="sig-name descname">is_gradient_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_gradient_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_gradient_required">
<em class="property">property </em><code class="sig-name descname">is_gradient_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_gradient_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_gradient_supported">
<em class="property">property </em><code class="sig-name descname">is_gradient_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_gradient_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is gradient supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_initial_point_ignored">
<em class="property">property </em><code class="sig-name descname">is_initial_point_ignored</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_initial_point_ignored" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point ignored</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_initial_point_required">
<em class="property">property </em><code class="sig-name descname">is_initial_point_required</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_initial_point_required" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point required</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.is_initial_point_supported">
<em class="property">property </em><code class="sig-name descname">is_initial_point_supported</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.is_initial_point_supported" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Returns is initial point supported</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_vars</span></em>, <em class="sig-param"><span class="n">objective_function</span></em>, <em class="sig-param"><span class="n">gradient_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variable_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_point</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qiskit/algorithms/optimizers/tnc.html#TNC.optimize"><span class="viewcode-link">[źródło]</span></a><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.optimize" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Perform optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_vars</strong> (<em>int</em>) – Number of parameters to be optimized.</p></li>
<li><p><strong>objective_function</strong> (<em>callable</em>) – A function that
computes the objective function.</p></li>
<li><p><strong>gradient_function</strong> (<em>callable</em>) – A function that
computes the gradient of the objective function, or
None if not available.</p></li>
<li><p><strong>variable_bounds</strong> (<em>list</em><em>[</em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>]</em>) – List of variable
bounds, given as pairs (lower, upper). None means
unbounded.</p></li>
<li><p><strong>initial_point</strong> (<em>numpy.ndarray</em><em>[</em><em>float</em><em>]</em>) – Initial point.</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p><dl class="simple">
<dt>point, value, nfev</dt><dd><p>point: is a 1D numpy.ndarray[float] containing the solution
value: is a float with the objective function value
nfev: number of objective function calls made if available or None</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Wyrzuca</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.print_options">
<code class="sig-name descname">print_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.print_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Print algorithm-specific options.</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.set_max_evals_grouped">
<code class="sig-name descname">set_max_evals_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.set_max_evals_grouped" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Set max evals grouped</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.set_options">
<code class="sig-name descname">set_options</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.set_options" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Sets or updates values in the options dictionary.</p>
<p>The options dictionary may be used internally by a given optimizer to
pass additional optional values for the underlying optimizer/optimization
function used. The options dictionary may be initially populated with
a set of key/values when the given optimizer is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><p><strong>kwargs</strong> (<em>dict</em>) – options, given as name=value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.setting">
<em class="property">property </em><code class="sig-name descname">setting</code><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.setting" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Return setting</p>
</dd></dl>

<dl class="py method">
<dt id="qiskit.algorithms.optimizers.TNC.wrap_function">
<em class="property">static </em><code class="sig-name descname">wrap_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qiskit.algorithms.optimizers.TNC.wrap_function" title="Stały odnośnik do tej definicji">¶</a></dt>
<dd><p>Wrap the function to implicitly inject the args at the call of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parametry</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>func</em>) – the target function</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – the args to be injected</p></li>
</ul>
</dd>
<dt class="field-even">Zwraca</dt>
<dd class="field-even"><p>wrapper</p>
</dd>
<dt class="field-odd">Typ zwracany</dt>
<dd class="field-odd"><p>function_wrapper</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../stubs/qiskit.algorithms.optimizers.OptimizerSupportLevel.html" class="btn btn-neutral float-right" title="qiskit.algorithms.optimizers.OptimizerSupportLevel" accesskey="n" rel="next">Next <img src="../_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="../stubs/qiskit.algorithms.VQE.html" class="btn btn-neutral" title="qiskit.algorithms.VQE" accesskey="p" rel="prev"><img src="../_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Qiskit Development Team.
      Ostatnia modyfikacja 2021/04/15.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">qiskit.algorithms.optimizers</a><ul>
<li><a class="reference internal" href="#optimizers-qiskit-algorithms-optimizers">Optimizers (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit.algorithms.optimizers</span></code>)</a></li>
<li><a class="reference internal" href="#optimizer-base-class">Optimizer Base Class</a></li>
<li><a class="reference internal" href="#local-optimizers">Local Optimizers</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#global-optimizers">Global Optimizers</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script src="../_static/jquery.js"></script>
         <script src="../_static/underscore.js"></script>
         <script src="../_static/doctools.js"></script>
         <script src="../_static/language_data.js"></script>
         <script src="../_static/thebelab-helper.js"></script>
         <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^0.21.0-alpha.0/dist/embed-amd.js"></script>
         <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
         <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <div>
    <br>
  </div>

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="../getting_started.html">Getting Started</a>
          </li>
          <li>
            <a href="../tutorials.html">Tutorials</a>
          </li>
          <li>
            <a href="https://qiskit.org/documentation/partners/">Providers</a>
          </li>
          <br>
          <li class="resources-mobile-menu-title">
            Applications
          </li>
          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://qiskit.org/documentation/machine-learning/">Machine learning</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/nature/">Nature</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/finance/">Finance</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/optimization/">Optimization</a>
            </li>
          </ul>

          <br>

          <li class="resources-mobile-menu-title">
            Resources
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://qiskit.slack.com">Slack support</a>
            </li>
          </ul>
          <br>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>